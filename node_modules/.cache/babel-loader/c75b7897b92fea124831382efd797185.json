{"ast":null,"code":"import { _optionalChain } from '@sentry/utils/esm/buildPolyfills';\nimport { logger, loadModule, fill, arrayify, isThenable } from '@sentry/utils';\nimport { shouldDisableAutoInstrumentation } from './utils/node-utils.js';\n\n/** Tracing integration for Apollo */\nclass Apollo {\n  constructor() {\n    Apollo.prototype.__init.call(this);\n  }\n  /**\n   * @inheritDoc\n   */\n  static __initStatic() {\n    this.id = 'Apollo';\n  }\n\n  /**\n   * @inheritDoc\n   */\n  __init() {\n    this.name = Apollo.id;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setupOnce(_, getCurrentHub) {\n    if (shouldDisableAutoInstrumentation(getCurrentHub)) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('Apollo Integration is skipped because of instrumenter configuration.');\n      return;\n    }\n    const pkg = loadModule('apollo-server-core');\n    if (!pkg) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Apollo Integration was unable to require apollo-server-core package.');\n      return;\n    }\n\n    /**\n     * Iterate over resolvers of the ApolloServer instance before schemas are constructed.\n     */\n    fill(pkg.ApolloServerBase.prototype, 'constructSchema', function (orig) {\n      return function () {\n        if (!this.config.resolvers) {\n          if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n            if (this.config.schema) {\n              logger.warn('Apollo integration is not able to trace `ApolloServer` instances constructed via `schema` property.');\n            } else if (this.config.modules) {\n              logger.warn('Apollo integration is not able to trace `ApolloServer` instances constructed via `modules` property.');\n            }\n            logger.error('Skipping tracing as no resolvers found on the `ApolloServer` instance.');\n          }\n          return orig.call(this);\n        }\n        const resolvers = arrayify(this.config.resolvers);\n        this.config.resolvers = resolvers.map(model => {\n          Object.keys(model).forEach(resolverGroupName => {\n            Object.keys(model[resolverGroupName]).forEach(resolverName => {\n              if (typeof model[resolverGroupName][resolverName] !== 'function') {\n                return;\n              }\n              wrapResolver(model, resolverGroupName, resolverName, getCurrentHub);\n            });\n          });\n          return model;\n        });\n        return orig.call(this);\n      };\n    });\n  }\n}\nApollo.__initStatic();\n\n/**\n * Wrap a single resolver which can be a parent of other resolvers and/or db operations.\n */\nfunction wrapResolver(model, resolverGroupName, resolverName, getCurrentHub) {\n  fill(model[resolverGroupName], resolverName, function (orig) {\n    return function () {\n      const scope = getCurrentHub().getScope();\n      const parentSpan = _optionalChain([scope, 'optionalAccess', _2 => _2.getSpan, 'call', _3 => _3()]);\n      const span = _optionalChain([parentSpan, 'optionalAccess', _4 => _4.startChild, 'call', _5 => _5({\n        description: `${resolverGroupName}.${resolverName}`,\n        op: 'graphql.resolve'\n      })]);\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      const rv = orig.call(this, ...args);\n      if (isThenable(rv)) {\n        return rv.then(res => {\n          _optionalChain([span, 'optionalAccess', _6 => _6.finish, 'call', _7 => _7()]);\n          return res;\n        });\n      }\n      _optionalChain([span, 'optionalAccess', _8 => _8.finish, 'call', _9 => _9()]);\n      return rv;\n    };\n  });\n}\nexport { Apollo };","map":{"version":3,"sources":["../../../../../src/integrations/node/apollo.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Hub } from '@sentry/core';\nimport type { EventProcessor, Integration } from '@sentry/types';\nimport { arrayify, fill, isThenable, loadModule, logger } from '@sentry/utils';\n\nimport { shouldDisableAutoInstrumentation } from './utils/node-utils';\n\ntype ApolloResolverGroup = {\n  [key: string]: () => unknown;\n};\n\ntype ApolloModelResolvers = {\n  [key: string]: ApolloResolverGroup;\n};\n\n/** Tracing integration for Apollo */\nexport class Apollo implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Apollo';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Apollo.id;\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(_: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    if (shouldDisableAutoInstrumentation(getCurrentHub)) {\n      __DEBUG_BUILD__ && logger.log('Apollo Integration is skipped because of instrumenter configuration.');\n      return;\n    }\n\n    const pkg = loadModule<{\n      ApolloServerBase: {\n        prototype: {\n          constructSchema: () => unknown;\n        };\n      };\n    }>('apollo-server-core');\n\n    if (!pkg) {\n      __DEBUG_BUILD__ && logger.error('Apollo Integration was unable to require apollo-server-core package.');\n      return;\n    }\n\n    /**\n     * Iterate over resolvers of the ApolloServer instance before schemas are constructed.\n     */\n    fill(pkg.ApolloServerBase.prototype, 'constructSchema', function (orig: () => unknown) {\n      return function (this: { config: { resolvers?: ApolloModelResolvers[]; schema?: unknown; modules?: unknown } }) {\n        if (!this.config.resolvers) {\n          if (__DEBUG_BUILD__) {\n            if (this.config.schema) {\n              logger.warn(\n                'Apollo integration is not able to trace `ApolloServer` instances constructed via `schema` property.',\n              );\n            } else if (this.config.modules) {\n              logger.warn(\n                'Apollo integration is not able to trace `ApolloServer` instances constructed via `modules` property.',\n              );\n            }\n\n            logger.error('Skipping tracing as no resolvers found on the `ApolloServer` instance.');\n          }\n\n          return orig.call(this);\n        }\n\n        const resolvers = arrayify(this.config.resolvers);\n\n        this.config.resolvers = resolvers.map(model => {\n          Object.keys(model).forEach(resolverGroupName => {\n            Object.keys(model[resolverGroupName]).forEach(resolverName => {\n              if (typeof model[resolverGroupName][resolverName] !== 'function') {\n                return;\n              }\n\n              wrapResolver(model, resolverGroupName, resolverName, getCurrentHub);\n            });\n          });\n\n          return model;\n        });\n\n        return orig.call(this);\n      };\n    });\n  }\n}\n\n/**\n * Wrap a single resolver which can be a parent of other resolvers and/or db operations.\n */\nfunction wrapResolver(\n  model: ApolloModelResolvers,\n  resolverGroupName: string,\n  resolverName: string,\n  getCurrentHub: () => Hub,\n): void {\n  fill(model[resolverGroupName], resolverName, function (orig: () => unknown | Promise<unknown>) {\n    return function (this: unknown, ...args: unknown[]) {\n      const scope = getCurrentHub().getScope();\n      const parentSpan = scope?.getSpan();\n      const span = parentSpan?.startChild({\n        description: `${resolverGroupName}.${resolverName}`,\n        op: 'graphql.resolve',\n      });\n\n      const rv = orig.call(this, ...args);\n\n      if (isThenable(rv)) {\n        return rv.then((res: unknown) => {\n          span?.finish();\n          return res;\n        });\n      }\n\n      span?.finish();\n\n      return rv;\n    };\n  });\n}\n"]},"metadata":{},"sourceType":"module"}